document.addEventListener('DOMContentLoaded', () => {
    const { createClient } = supabase;

    const projectForm = document.getElementById('project-form');
    const logContainer = document.getElementById('log-container');
    const projectGrid = document.getElementById('project-grid');
    const connectionStatus = document.getElementById('connection-status');
    const connectBtn = document.getElementById('connect-btn');

    let projects = JSON.parse(localStorage.getItem('supabase_projects')) || [];
    let activeTimers = {};
    let adminClients = {};

    const log = (message, level = 'info') => {
        const time = new Date().toLocaleTimeString();
        const color = level === 'error' ? '#ef4444' : (level === 'success' ? '#22c55e' : '#94a3b8');
        logContainer.innerHTML += `<div><span style="color: #64748b;">[${time}]</span> ${message}</div>`;
        logContainer.scrollTop = logContainer.scrollHeight;
    };

    const getAdminClient = (project, forceRefresh = false) => {
        if (!adminClients[project.id] || forceRefresh) {
            adminClients[project.id] = createClient(project.url, project.serviceKey);
        }
        return adminClients[project.id];
    };

    const setupProject = async (project) => {
        log(`Iniciando configuração para <strong>${project.name}</strong>...`);
        connectionStatus.innerHTML = `Verificando conexão...`;
        let adminClient = getAdminClient(project, true);

        try {
            const { data: tableData, error: checkError } = await adminClient.rpc('execute_sql_and_return', {
                sql: `SELECT to_json(information_schema.tables) FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'keep_alive';`
            });

            if (checkError) throw new Error(`Falha ao verificar tabela: ${checkError.message}`);

            if (tableData.length === 0) {
                log(`Tabela 'keep_alive' não encontrada. Criando...`);
                connectionStatus.innerHTML = `Tabela não encontrada. Criando...`;
                const createTableSql = `CREATE TABLE public.keep_alive (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, created_at TIMESTAMPTZ, mensagem TEXT);`;
                const { error: createError } = await adminClient.rpc('execute_sql', { sql: createTableSql });
                if (createError) throw new Error(`Falha ao criar tabela: ${createError.message}.`);
                log(`Tabela 'keep_alive' criada com sucesso!`, 'success');
                
                adminClient = getAdminClient(project, true);
                
                log(`Desativando RLS para 'keep_alive'...`);
                connectionStatus.innerHTML = `Desativando RLS...`;
                const disableRlsSql = `ALTER TABLE public.keep_alive DISABLE ROW LEVEL SECURITY;`;
                const { error: rlsError } = await adminClient.rpc('execute_sql', { sql: disableRlsSql });
                if (rlsError) throw new Error(`Falha ao desativar RLS: ${rlsError.message}.`);
                log(`RLS desativada com sucesso.`, 'success');

            } else {
                log(`Tabela 'keep_alive' já existe. Verificando estrutura...`);
                const { data: columnsData, error: columnsError } = await adminClient.rpc('execute_sql_and_return', {
                    sql: `SELECT json_agg(json_build_object('name', column_name, 'type', udt_name)) FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'keep_alive';`
                });

                if (columnsError) throw new Error(`Falha ao verificar colunas: ${columnsError.message}`);
                
                const columns = columnsData[0].result;
                const hasId = columns.some(c => c.name === 'id' && c.type === 'int8');
                const hasCreatedAt = columns.some(c => c.name === 'created_at' && c.type === 'timestamptz');
                const hasMensagem = columns.some(c => c.name === 'mensagem' && c.type === 'text');

                if (hasId && hasCreatedAt && hasMensagem) {
                    log(`Estrutura da tabela 'keep_alive' está correta.`, 'success');
                } else {
                    let missing = [];
                    if (!hasId) missing.push("id (bigint)");
                    if (!hasCreatedAt) missing.push("created_at (timestamptz)");
                    if (!hasMensagem) missing.push("mensagem (text)");
                    throw new Error(`Tabela 'keep_alive' existe, mas a estrutura está incorreta. Colunas faltando ou com tipo errado: ${missing.join(', ')}. Por favor, delete a tabela e tente novamente.`);
                }
            }
            
            connectionStatus.innerHTML = `<span style="color:var(--success-color);">Projeto configurado!</span>`;
            return true;
        } catch (error) {
            log(error.message, 'error');
            connectionStatus.innerHTML = `<span style="color:var(--danger-color);">${error.message}</span>`;
            return false;
        }
    };

    const executeKeepAliveOperation = async (project) => {
        if (!project.active) return;
        const client = createClient(project.url, project.anonKey);
        try {
            log(`Executando operação em <strong>${project.name}</strong>...`);
            
            const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000).toISOString();
            const { error: deleteError } = await client.from('keep_alive').delete().lt('created_at', fiveMinutesAgo);
            if (deleteError) log(`Aviso: falha ao limpar registros antigos: ${deleteError.message}`, 'error');
            else log(`&larr; Registros antigos (com mais de 5 min) foram limpos.`);

            const { error: insertError } = await client.from('keep_alive').insert({ 
                created_at: new Date().toISOString(),
                mensagem: "Cadastro de atividade para você ver" 
            });
            if (insertError) throw new Error(`Falha ao inserir: ${insertError.message}`);
            log(`&rarr; Novo registro de atividade inserido em <strong>${project.name}</strong>.`, 'success');
        } catch (error) {
            log(`Erro na operação em '${project.name}': ${error.message}`, 'error');
        }
    };

    const startKeepAlive = (project) => {
        if (activeTimers[project.id]) clearInterval(activeTimers[project.id]);
        if (!project.active) return;
        const intervalMillis = project.interval * 60 * 1000;
        executeKeepAliveOperation(project);
        activeTimers[project.id] = setInterval(() => executeKeepAliveOperation(project), intervalMillis);
        log(`Automação iniciada para <strong>${project.name}</strong>. Intervalo: ${project.interval} min.`);
    };

    const saveAndRender = () => {
        localStorage.setItem('supabase_projects', JSON.stringify(projects));
        renderProjects();
    };

    const renderProjects = () => {
        projectGrid.innerHTML = '';
        if (projects.length === 0) {
            projectGrid.innerHTML = `<p>Nenhum projeto adicionado ainda.</p>`;
        }
        projects.forEach(p => {
            const card = document.createElement('div');
            card.className = 'project-card';
            card.dataset.id = p.id;
            card.innerHTML = `
                <h3>${p.name}</h3>
                <div class="status">
                    <div class="status-indicator ${p.active ? 'active' : 'paused'}"></div>
                    <span>${p.active ? 'Ativo' : 'Pausado'}</span>
                </div>
                <div class="controls">
                    <label for="interval-${p.id}">Intervalo (minutos):</label>
                    <input type="number" class="interval-input" id="interval-${p.id}" value="${p.interval}" min="1">
                </div>
                <div class="actions">
                    <button class="toggle-btn ${p.active ? 'active' : 'paused'}">${p.active ? 'Pausar' : 'Iniciar'}</button>
                    <button class="delete-btn">Remover</button>
                </div>
            `;
            projectGrid.appendChild(card);
        });
    };

    projectForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        connectBtn.disabled = true;
        connectBtn.textContent = 'Conectando...';

        const newProject = {
            id: Date.now(),
            name: document.getElementById('projectName').value,
            url: document.getElementById('supabaseUrl').value,
            anonKey: document.getElementById('supabaseAnonKey').value,
            serviceKey: document.getElementById('supabaseServiceKey').value,
            interval: 60,
            active: true
        };

        const success = await setupProject(newProject);

        if (success) {
            projects.push(newProject);
            saveAndRender();
            startKeepAlive(newProject);
            projectForm.reset();
        }
        
        setTimeout(() => {
            connectionStatus.innerHTML = '';
            connectBtn.disabled = false;
            connectBtn.textContent = 'Adicionar e Configurar';
        }, 3000);
    });

    projectGrid.addEventListener('click', (e) => {
        const card = e.target.closest('.project-card');
        if (!card) return;
        const projectId = Number(card.dataset.id);
        const project = projects.find(p => p.id === projectId);

        if (e.target.classList.contains('toggle-btn')) {
            project.active = !project.active;
            if (project.active) {
                startKeepAlive(project);
            } else {
                clearInterval(activeTimers[project.id]);
                log(`Automação pausada para <strong>${project.name}</strong>.`);
            }
        }
        if (e.target.classList.contains('delete-btn')) {
            if (confirm(`Tem certeza que deseja remover o projeto ${project.name}?`)) {
                clearInterval(activeTimers[project.id]);
                projects = projects.filter(p => p.id !== projectId);
                log(`Projeto <strong>${project.name}</strong> removido.`);
            }
        }
        saveAndRender();
    });

    projectGrid.addEventListener('change', (e) => {
        if (e.target.classList.contains('interval-input')) {
            const card = e.target.closest('.project-card');
            const projectId = Number(card.dataset.id);
            const project = projects.find(p => p.id === projectId);
            project.interval = Number(e.target.value);
            saveAndRender();
            startKeepAlive(project);
            log(`Intervalo para <strong>${project.name}</strong> atualizado para ${project.interval} min.`);
        }
    });

    const initialize = () => {
        renderProjects();
        projects.forEach(startKeepAlive);
        log("Supabase Sentinel iniciado. Projetos carregados.");
    };

    initialize();
});
