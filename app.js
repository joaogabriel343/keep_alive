// app.js (Versão Corrigida e Funcional)

document.addEventListener('DOMContentLoaded', () => {
    const { createClient } = supabase;

    // Elementos da Interface
    const addProjectBtn = document.getElementById('add-project-btn');
    const modalBackdrop = document.getElementById('modal-backdrop');
    const projectForm = document.getElementById('project-form');
    const logContainer = document.getElementById('log-container');
    const projectGrid = document.getElementById('project-grid');
    const connectionStatus = document.getElementById('connection-status');
    const connectBtn = document.getElementById('connect-btn');
    const closeModalBtn = document.querySelector('.close-modal-btn'); // Variável que faltava

    // Armazenamento local
    let projects = JSON.parse(localStorage.getItem('supabase_projects')) || [];
    let activeTimers = {};

    // --- Funções de Controle do Modal (Corrigidas) ---
    const openModal = () => {
        projectForm.reset();
        connectionStatus.innerHTML = '';
        connectBtn.disabled = false;
        connectBtn.textContent = 'Conectar e Configurar';
        modalBackdrop.classList.remove('hidden');
    };

    const closeModal = () => {
        modalBackdrop.classList.add('hidden');
    };

    // --- Lógica Principal (sem alterações) ---
    const log = (message, level = 'info') => {
        const time = new Date().toLocaleTimeString();
        const color = level === 'error' ? '#ef4444' : (level === 'success' ? '#22c55e' : '#94a3b8');
        logContainer.innerHTML += `<div style="color:${color};">[${time}] ${message}</div>`;
        logContainer.scrollTop = logContainer.scrollHeight;
    };

    const getAdminClient = (project) => createClient(project.url, project.serviceKey);

    const setupProject = async (project) => {
        log(`Iniciando configuração para <strong>${project.name}</strong>...`);
        connectionStatus.innerHTML = `Verificando conexão com ${project.name}...`;
        const adminClient = getAdminClient(project);

        try {
            const { error: checkError } = await adminClient.from('keep_alive').select('id').limit(1);

            if (checkError) {
                log(`Tabela 'keep_alive' não encontrada. Criando...`);
                connectionStatus.innerHTML = `Tabela não encontrada. Criando...`;

                const createTableSql = `CREATE TABLE public.keep_alive (id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, created_at TIMESTAMPTZ);`;
                const { error: createError } = await adminClient.rpc('execute_sql', { sql: createTableSql });
                if (createError) throw new Error(`Falha ao criar tabela: ${createError.message}.`);
                log(`Tabela 'keep_alive' criada com sucesso!`, 'success');

                log(`Desativando Row Level Security para a tabela 'keep_alive'...`);
                connectionStatus.innerHTML = `Desativando RLS...`;
                const disableRlsSql = `ALTER TABLE public.keep_alive DISABLE ROW LEVEL SECURITY;`;
                const { error: rlsError } = await adminClient.rpc('execute_sql', { sql: disableRlsSql });
                if (rlsError) throw new Error(`Falha ao desativar RLS: ${rlsError.message}.`);
                log(`RLS desativada com sucesso para 'keep_alive'.`, 'success');
            } else {
                log(`Tabela 'keep_alive' já existe.`);
            }

            connectionStatus.innerHTML = `<span style="color:green;">Projeto configurado com sucesso!</span>`;
            return true;
        } catch (error) {
            log(error.message, 'error');
            connectionStatus.innerHTML = `<span style="color:red;">${error.message}</span>`;
            return false;
        }
    };

    const pingProject = async (project) => {
        if (!project.active) return;
        const client = createClient(project.url, project.anonKey);
        try {
            log(`Ping para <strong>${project.name}</strong>...`);
            const { data, error: insertError } = await client.from('keep_alive').insert({ created_at: new Date().toISOString() }).select('id').single();
            if (insertError) throw insertError;
            const { error: deleteError } = await client.from('keep_alive').delete().eq('id', data.id);
            if (deleteError) throw deleteError;
            log(`Ping para <strong>${project.name}</strong> bem-sucedido.`, 'success');
        } catch (error) {
            log(`Erro de ping em '${project.name}': ${error.message}`, 'error');
        }
    };

    const startPinging = (project) => {
        if (activeTimers[project.id]) clearInterval(activeTimers[project.id]);
        if (!project.active) return;
        const intervalMillis = project.interval * 60 * 1000;
        pingProject(project);
        activeTimers[project.id] = setInterval(() => pingProject(project), intervalMillis);
        log(`Automação iniciada para <strong>${project.name}</strong>. Intervalo: ${project.interval} minutos.`);
    };

    const saveAndRender = () => {
        localStorage.setItem('supabase_projects', JSON.stringify(projects));
        renderProjects();
    };

    const renderProjects = () => {
        projectGrid.innerHTML = '';
        projects.forEach(p => {
            const card = document.createElement('div');
            card.className = 'project-card';
            card.dataset.id = p.id;
            card.innerHTML = `
                <h3>${p.name}</h3>
                <div class="status">
                    <div class="status-indicator ${p.active ? 'active' : 'paused'}"></div>
                    <span>${p.active ? 'Ativo' : 'Pausado'}</span>
                </div>
                <div class="controls">
                    <label for="interval-${p.id}">Intervalo (minutos):</label>
                    <input type="number" id="interval-${p.id}" value="${p.interval}" min="1">
                </div>
                <div class="actions">
                    <button class="toggle-btn ${p.active ? 'active' : 'paused'}">${p.active ? 'Pausar' : 'Iniciar'}</button>
                    <button class="delete-btn">Remover</button>
                </div>
            `;
            projectGrid.appendChild(card);
        });
    };

    // --- Event Listeners (Ouvintes de Ação) ---
    projectForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        connectBtn.disabled = true;
        connectBtn.textContent = 'Conectando...';

        const newProject = {
            id: Date.now(),
            name: document.getElementById('projectName').value,
            url: document.getElementById('supabaseUrl').value,
            anonKey: document.getElementById('supabaseAnonKey').value,
            serviceKey: document.getElementById('supabaseServiceKey').value,
            interval: 60,
            active: true
        };

        const success = await setupProject(newProject);

        if (success) {
            projects.push(newProject);
            saveAndRender();
            startPinging(newProject);
            setTimeout(closeModal, 1500);
        } else {
            connectBtn.disabled = false;
            connectBtn.textContent = 'Conectar e Configurar';
        }
    });

    projectGrid.addEventListener('click', (e) => {
        const card = e.target.closest('.project-card');
        if (!card) return;
        const projectId = Number(card.dataset.id);
        const project = projects.find(p => p.id === projectId);

        if (e.target.classList.contains('toggle-btn')) {
            project.active = !project.active;
            if (project.active) {
                startPinging(project);
            } else {
                clearInterval(activeTimers[project.id]);
                log(`Automação pausada para <strong>${project.name}</strong>.`);
            }
        }
        if (e.target.classList.contains('delete-btn')) {
            if (confirm(`Tem certeza que deseja remover o projeto ${project.name}?`)) {
                clearInterval(activeTimers[project.id]);
                projects = projects.filter(p => p.id !== projectId);
                log(`Projeto <strong>${project.name}</strong> removido.`);
            }
        }
        saveAndRender();
    });

    projectGrid.addEventListener('change', (e) => {
        if (e.target.tagName === 'INPUT') {
            const card = e.target.closest('.project-card');
            const projectId = Number(card.dataset.id);
            const project = projects.find(p => p.id === projectId);
            project.interval = Number(e.target.value);
            saveAndRender();
            startPinging(project);
            log(`Intervalo para <strong>${project.name}</strong> atualizado para ${project.interval} minutos.`);
        }
    });

    // --- Event Listeners do Modal (Corrigidos) ---
    addProjectBtn.addEventListener('click', openModal);
    closeModalBtn.addEventListener('click', closeModal);
    modalBackdrop.addEventListener('click', (e) => {
        if (e.target === modalBackdrop) {
            closeModal();
        }
    });
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !modalBackdrop.classList.contains('hidden')) {
            closeModal();
        }
    });

    // Função de inicialização
    const initialize = () => {
        renderProjects();
        projects.forEach(startPinging);
        log("Supabase Sentinel iniciado. Projetos carregados.");
    };

    initialize();
});
